import numpy as np
from sklearn.cluster import DBSCAN

# 假设给定的点云
points_3d = np.array([...])  # 形状为 (N, 3)
K = np.array([...])          # 摄像机内参矩阵 (3, 3)
R = np.array([...])          # 摄像机旋转矩阵 (3, 3)
t = np.array([...])          # 摄像机平移向量 (3, 1)
bbox_2d = (xmin, ymin, xmax, ymax)  # 给定的2D边界框

# 将3D点投影到2D空间
points_3d_homo = np.hstack((points_3d, np.ones((points_3d.shape[0], 1))))  # 3D点转为齐次坐标
P = K @ np.hstack((R, t))  # 计算投影矩阵 KRt
points_2d_homo = P @ points_3d_homo.T  # 投影到2D空间 (3, N)

# 转换为实际的2D坐标
points_2d = points_2d_homo[:2, :] / points_2d_homo[2, :]  # 除以第三个坐标，归一化为2D坐标 (2, N)

# 找到2D边界框内的点
mask = (points_2d[0, :] >= bbox_2d[0]) & (points_2d[0, :] <= bbox_2d[2]) & \
       (points_2d[1, :] >= bbox_2d[1]) & (points_2d[1, :] <= bbox_2d[3])
inliers = points_3d[mask]  # 位于2D框内的3D点

# 对这些点进行聚类以消除异常值
clustering = DBSCAN(eps=0.5, min_samples=5).fit(inliers)
labels = clustering.labels_

# 获取主要聚类的点，即标签不为-1的点
core_points = inliers[labels != -1]

# 计算这些点的3D边界框 (通常为AABB)
min_corner = np.min(core_points, axis=0)
max_corner = np.max(core_points, axis=0)
bounding_box_3d = (min_corner, max_corner)

# 打印或返回结果
print("3D Bounding Box:", bounding_box_3d)



def project_from_ego_to_cam(pts_3d, extrinsic):
    pts_3d_hom = np.hstack((pts_3d, np.ones((pts_3d.shape[0], 1))))
    uv_cam = extrinsic.dot(pts_3d_hom.transpose()).transpose()[:, 0:3]
    return uv_cam


def project_cam_to_image(intrinsic, points_rect):
    hom = np.hstack((points_rect, np.ones((points_rect.shape[0], 1))))
    pts_2d = np.dot(hom, np.transpose(intrinsic)) # nx3
    pts_2d[:,0] /= pts_2d[:,2]
    pts_2d[:,1] /= pts_2d[:,2]
    return pts_2d[:, :2]
